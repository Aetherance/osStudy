# 0

## 访问硬件的两个方式

1. 内存映射I/O 
2. 通过I/O接口通信

内存映射I/O设备的内存会被映射到一定范围的地址空间，CPU可以通过访问系统内存来访问外部设备。

通过I/O接口通信的设备的地址空间和系统是分开的，它们通过I/O接口和CPU通信。

## “陷入内核”

应用程序处于特权级3 操作系统处于特权级0。应用程序想要访问系统资源，就要进行系统调用。

当CPU处于用户态时，无法进行硬件资源的访问和特权指令的执行，因此CPU需要切换到内核态来进行这些操作。

## 内存分段

CPU通过`寄存器`来访问内存，而早期CPU和寄存器都是16位的。16位寄存器能表示的最大的数是2^16(65536)，这导致寄存器最多能访问65535字节内存，也就是64MB。

两个编译出来地址相同的程序是没有办法同时运行的。内存分段可以解决这个问题。

## 物理地址、逻辑地址、有效地址、线性地址、虚拟地址

物理地址就是物理内存的真正地址，具有`唯一性`，CPU最终都要以物理地址去访问内存。

在实模式，`段基址+段内偏移地址`经过处理就是`物理地址`。 而在保护模式下，其被称为`线性地址`。

无论是实模式还是保护模式，段内偏移地址被称为`有效地址`又叫`逻辑地址`。

## 段寄存器
1. CS 代码段寄存器，值为代码段的段基值。
2. DS 数据段寄存器，值为数据段的段基值。
3. ES 附加段寄存器，值为附加数据段的段基值。
4. FS 附加段寄存器。
5. GS 附加段寄存器。
6. SS 堆栈段寄存器。

## CPU的两种模式

CPU有两种模式——实模式和保护模式。

实模式的CS，DS，ES，SS值为段基址，是具体的物理地址。

保护模式下，段寄存器中不再是段地址，而是`段选择子`，类似数组下标。

## 函数参数为何放在栈区

1. 局部变量，方便随时清理
2. 不浪费数据段的空间
3. 无法确定函数会被调用几次，防止无意义的占用空间

## 编译型程序和解释型程序

解释型程序的代码并没有在CPU上执行，解释型程序也并不是一个独立的进程。

解释型程序由解释器根据解释型程序内容作出响应，实际执行的还是解释器。

而编译型程序确实由CPU执行，并在运行时是一个独立的进程。

## 大小端

大端序将低字节放在高地址处，小端将低字节放在低地址处。

大端存储优势：读符号位方便

小段存储优势：计算机操作更方便

## 异常和中断

来自CPU内部的事件发生称为`异常`

来自CPU外部的事件发生称为`中断`

## Section 和 Segment

C程序4个阶段：
预处理、编译、汇编、链接

在汇编源码中，常用section或segment来表示一段区域。

Section称为节，是指在汇编源码中经由关键字section 或segment 修饰、逻辑划分的指令或数据区域。

segment 称为段，是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合。 segment存在于可执行文件中。

## 库函数

使用#include<>包含头文件后，在链接阶段，编译器会自动链接上标准函数函数体的目标文件。而#include的头文件中是没有函数体的。

## MBR 、EBR、DBR 和OBR 各是什么

MBR 是主引导记录，Master 或 Main Boot Record，它存在于整个硬盘最开始的那个扇区。

在MBR 引导扇区中存储引导程序，为的是从BIOS 手中接过系统的控制权。

EBR是扩展分区中为了兼容MBR 才提出的概念，主要是兼容MBR中的分区表。

DOS时代只有4个分区，不存在扩展分区，这4个分区都相当于主分区，所以各主分区最开始的扇区称为DBR引导扇区。DBR也称为OBR。